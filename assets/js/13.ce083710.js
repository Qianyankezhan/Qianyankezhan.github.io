(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{205:function(e,v,_){"use strict";_.r(v);var t=_(0),a=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"vue面试题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue面试题"}},[e._v("#")]),e._v(" Vue面试题")]),e._v(" "),_("h2",{attrs:{id:"_0-vue-js是什么？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_0-vue-js是什么？"}},[e._v("#")]),e._v(" 0.vue.js是什么？")]),e._v(" "),_("p",[e._v("Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。")]),e._v(" "),_("h2",{attrs:{id:"_1-vue中的通信都有哪些？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue中的通信都有哪些？"}},[e._v("#")]),e._v(" 1.vue中的通信都有哪些？")]),e._v(" "),_("p",[e._v("父子通信，兄弟通信，跨级通信。")]),e._v(" "),_("h2",{attrs:{id:"_2-父子通信的方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-父子通信的方式"}},[e._v("#")]),e._v(" 2.父子通信的方式")]),e._v(" "),_("ol",[_("li",[_("p",[_("code",[e._v("props")]),e._v("/"),_("code",[e._v("$emit")]),e._v("：是Vue中最常见的父子通信方式。在子组件中定义一个"),_("code",[e._v("props")]),e._v("，来接受父组件传过来的值，并在子组件中使用。子组件调用"),_("code",[e._v("this.$emit()")]),e._v("方法，回调父组件的方法并可以传递相关数据。")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("this.$parent")]),e._v("/"),_("code",[e._v("$children")]),e._v("：子组件可以用"),_("code",[e._v("this.$parent")]),e._v("访问父组件，子组件被推入父组件的"),_("code",[e._v("$children")]),e._v("数组中。")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("$refs")]),e._v(":父组件可以通过"),_("code",[e._v("$refs")]),e._v("访问子组件实例。")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("provide")]),e._v("/"),_("code",[e._v("inject")]),e._v(": 允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("$attrs")]),e._v("/"),_("code",[e._v("$listeners")]),e._v("： "),_("code",[e._v("$attrs")]),e._v("包含了父作用域中不作为"),_("code",[e._v("prop")]),e._v("被识别(且获取)的特性绑定("),_("code",[e._v("class")]),e._v("和"),_("code",[e._v("style")]),e._v("除外)。当一个组件没有声明任何"),_("code",[e._v("prop")]),e._v("时，这里会包含所有父作用域的绑定("),_("code",[e._v("class")]),e._v("和"),_("code",[e._v("style")]),e._v("除外)，并且可以通过 "),_("code",[e._v('v-bind="$attrs"')]),e._v("传入内部组件。"),_("code",[e._v("$listeners")]),e._v("包含了父作用域中的(不含"),_("code",[e._v(".native")]),e._v("修饰器的)"),_("code",[e._v("v-on")]),e._v(" 事件监听器。它可以通过"),_("code",[e._v('v-on="$listeners"')]),e._v("传入内部组件")])])]),e._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[e._v("注意")]),e._v(" "),_("ul",[_("li",[e._v("节制地使用"),_("code",[e._v("$parent")]),e._v("和"),_("code",[e._v("$children")]),e._v(" - 它们的主要目的是作为访问组件的应急方法。更推荐用"),_("code",[e._v("props")]),e._v("和"),_("code",[e._v("events")]),e._v("实现父子组件通信")]),e._v(" "),_("li",[_("code",[e._v("provide")]),e._v("和"),_("code",[e._v("inject")]),e._v("主要为高阶插件/组件库提供用例，并不推荐直接用于应用程序代码中。")]),e._v(" "),_("li",[_("code",[e._v("$attrs")]),e._v("和"),_("code",[e._v("$listeners")]),e._v("主要为在创建更高层次的组件时使用。")])])]),e._v(" "),_("h2",{attrs:{id:"_3-兄弟通信的方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-兄弟通信的方式"}},[e._v("#")]),e._v(" 3.兄弟通信的方式")]),e._v(" "),_("p",[_("code",[e._v("vuex")])]),e._v(" "),_("h2",{attrs:{id:"_4-跨级通信的方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-跨级通信的方式"}},[e._v("#")]),e._v(" 4.跨级通信的方式")]),e._v(" "),_("p",[_("code",[e._v("vuex")]),e._v("、"),_("code",[e._v("provide")]),e._v("/"),_("code",[e._v("inject")]),e._v("、"),_("code",[e._v("$attrs")]),e._v("/"),_("code",[e._v("$listeners")])]),e._v(" "),_("h2",{attrs:{id:"_5-什么是vuex？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-什么是vuex？"}},[e._v("#")]),e._v(" 5.什么是Vuex？")]),e._v(" "),_("p",[e._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。")]),e._v(" "),_("h2",{attrs:{id:"_6-vuex的核心概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-vuex的核心概念"}},[e._v("#")]),e._v(" 6.Vuex的核心概念")]),e._v(" "),_("ol",[_("li",[_("code",[e._v("state")]),e._v("："),_("code",[e._v("Vuex")]),e._v("管理状态的对象，它应该是唯一的。")]),e._v(" "),_("li",[_("code",[e._v("mutations")]),e._v("：包含多个直接更新"),_("code",[e._v("state")]),e._v("的方法（回调函数）的对象，由"),_("code",[e._v("action")]),e._v("中的"),_("code",[e._v("commit")]),e._v("调用。"),_("code",[e._v("mutations")]),e._v("中只能包含同步方法。")]),e._v(" "),_("li",[_("code",[e._v("actions")]),e._v("：包含多个时间回调函数的对象，由"),_("code",[e._v("$store.dispatch()")]),e._v("方法触发。"),_("code",[e._v("actions")]),e._v("中可以包含异步代码。")]),e._v(" "),_("li",[_("code",[e._v("getters")]),e._v("：包含多个计算属性（get）的对象，由"),_("code",[e._v("$store.getters.XXX")]),e._v("读取。")]),e._v(" "),_("li",[_("code",[e._v("modules")]),e._v("：store的集合。")])]),e._v(" "),_("h2",{attrs:{id:"_7-vue的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue的生命周期"}},[e._v("#")]),e._v(" 7.Vue的生命周期")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("beforeCreate")]),e._v("：创建前 组件实例更被创建，组件属性计算之前，数据对象"),_("code",[e._v("data")]),e._v("都为"),_("code",[e._v("undefined")]),e._v("，未初始化。")]),e._v(" "),_("li",[_("code",[e._v("created")]),e._v("：创建后 组件实例创建完成，属性已经绑定，数据对象data已存在，但"),_("code",[e._v("dom")]),e._v("未生成，"),_("code",[e._v("$el")]),e._v("未存在。")]),e._v(" "),_("li",[_("code",[e._v("beforeMount")]),e._v("：挂载前 vue实例的"),_("code",[e._v("$el")]),e._v("和"),_("code",[e._v("data")]),e._v("都已初始化，挂载之前为虚拟的"),_("code",[e._v("dom")]),e._v("节点，"),_("code",[e._v("data.message")]),e._v("未替换。")]),e._v(" "),_("li",[_("code",[e._v("mounted")]),e._v("：挂载后 vue实例挂载完成，"),_("code",[e._v("data.message")]),e._v("成功渲染。")]),e._v(" "),_("li",[_("code",[e._v("beforeUpdate")]),e._v("：更新前 当data变化时，会触发"),_("code",[e._v("beforeUpdate")]),e._v("方法。")]),e._v(" "),_("li",[_("code",[e._v("updated")]),e._v("：更新后 当"),_("code",[e._v("data")]),e._v("变化时，会触发"),_("code",[e._v("updated")]),e._v("方法。")]),e._v(" "),_("li",[_("code",[e._v("beforeDestroy")]),e._v("：销毁前 组件销毁之前调用。")]),e._v(" "),_("li",[_("code",[e._v("destroyed")]),e._v("：销毁后 组件销毁之后调用，对"),_("code",[e._v("data")]),e._v("的改变不会再触发周期函数，vue实例已解除"),_("code",[e._v("dom")]),e._v("监听和数据绑定，但"),_("code",[e._v("dom")]),e._v("结构依然存在")])]),e._v(" "),_("h2",{attrs:{id:"_8-实例是在哪个阶段创建完的？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-实例是在哪个阶段创建完的？"}},[e._v("#")]),e._v(" 8.实例是在哪个阶段创建完的？")]),e._v(" "),_("p",[e._v("在mounted阶段实例创建完成。")]),e._v(" "),_("h2",{attrs:{id:"_9-实例初始化是在哪个阶段？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-实例初始化是在哪个阶段？"}},[e._v("#")]),e._v(" 9.实例初始化是在哪个阶段？")]),e._v(" "),_("p",[e._v("在created阶段实例初始化，但还未完成。")]),e._v(" "),_("h2",{attrs:{id:"_10-vue的实现原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue的实现原理"}},[e._v("#")]),e._v(" 10.Vue的实现原理")]),e._v(" "),_("p",[e._v("Vue采用的是数据劫持，结合发布者和订阅者模式，通过"),_("code",[e._v("Object.defineProperty()")]),e._v("，来对于每个属性的"),_("code",[e._v("getter")]),e._v("和"),_("code",[e._v("setter")]),e._v("进行劫持，在数据更改时，发布消息给到订阅者，重新渲染页面。")]),e._v(" "),_("h2",{attrs:{id:"_11-hash与history两种模式区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-hash与history两种模式区别"}},[e._v("#")]),e._v(" 11.hash与history两种模式区别")]),e._v(" "),_("p",[e._v("直观上的区别就是差一个“#”，hash模式的地址包含"),_("code",[e._v("#")]),e._v("；但history模式没有。")]),e._v(" "),_("p",[e._v("hash模式使用 URL 的"),_("code",[e._v("hash")]),e._v("来模拟一个完整的 URL，例如"),_("code",[e._v("http://yoursite.com/#/user/id")]),e._v("，于是当 URL 改变时，页面不会重新加载。")]),e._v(" "),_("p",[e._v("history模式的 URL 就像正常的"),_("code",[e._v("url")]),e._v("，例如"),_("code",[e._v("http://yoursite.com/user/id")]),e._v("。但是该模式需要后台配置的配合，需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个"),_("code",[e._v("index.html")]),e._v("页面，这个页面就是 app 依赖的页面")]),e._v(" "),_("h2",{attrs:{id:"_12-keep-alive-的作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-keep-alive-的作用"}},[e._v("#")]),e._v(" 12."),_("code",[e._v("<keep-alive>")]),e._v("的作用")]),e._v(" "),_("p",[_("code",[e._v("<keep-alive>")]),e._v(" 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们,它主要用于保留组件状态或避免重新渲染。和 "),_("code",[e._v("<transition>")]),e._v(" 相似，"),_("code",[e._v("<keep-alive>")]),e._v(" 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。")]),e._v(" "),_("p",[e._v("当组件在 "),_("code",[e._v("<keep-alive>")]),e._v(" 内被切换，它的 "),_("code",[e._v("activated")]),e._v(" 和 "),_("code",[e._v("deactivated")]),e._v(" 这两个生命周期钩子函数将会被对应执行。")]),e._v(" "),_("div",{staticClass:"custom-block danger"},[_("p",{staticClass:"custom-block-title"},[e._v("注意")]),e._v(" "),_("p",[_("code",[e._v("<keep-alive>")]),e._v(" 是用在其一个直属的子组件被开关的情形。如果你在其中有 "),_("code",[e._v("v-for")]),e._v(" 则不会工作。如果有上述的多个条件性的子元素，"),_("code",[e._v("<keep-alive>")]),e._v(" 要求同时只有一个子元素被渲染。")])]),e._v(" "),_("p",[e._v("关键字：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("include")]),e._v(" - 字符串或正则表达式。只有名称匹配的组件会被缓存。")]),e._v(" "),_("li",[_("code",[e._v("exclude")]),e._v(" - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。")]),e._v(" "),_("li",[_("code",[e._v("max")]),e._v(" - 数字。最多可以缓存多少组件实例。")])]),e._v(" "),_("h2",{attrs:{id:"_12-简单描述每个周期具体适合哪些场景？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-简单描述每个周期具体适合哪些场景？"}},[e._v("#")]),e._v(" 12.简单描述每个周期具体适合哪些场景？")]),e._v(" "),_("p",[_("code",[e._v("beforecreate")]),e._v(": 可以在这加个"),_("code",[e._v("loading")]),e._v("事件，在加载实例时触发\n"),_("code",[e._v("created")]),e._v(": 初始化完成时的事件写在这里，如在这结束"),_("code",[e._v("loading")]),e._v("事件，异步请求也适宜在这里调用\n"),_("code",[e._v("mounted")]),e._v(": 挂载元素，获取到"),_("code",[e._v("DOM")]),e._v("节点\n"),_("code",[e._v("updated")]),e._v(": 如果对数据统一处理，在这里写上相应函数\n"),_("code",[e._v("beforeDestroy")]),e._v(": 可以做一个确认停止事件的确认框")]),e._v(" "),_("h2",{attrs:{id:"参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://yq.aliyun.com/articles/711158",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端常见Vue面试题（新）"),_("OutboundLink")],1)]),e._v(" "),_("p",[_("a",{attrs:{href:"https://segmentfault.com/a/1190000020053344#item-5",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue中8种组件通信方式"),_("OutboundLink")],1)]),e._v(" "),_("p",[_("a",{attrs:{href:"https://blog.csdn.net/weixin_38292678/article/details/82824574",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue面试题"),_("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=a.exports}}]);